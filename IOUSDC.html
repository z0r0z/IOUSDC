
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>IOUSDC</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📄</text></svg>"
    />
    <!-- Ethers v5 (kept to ensure compatibility with many wallets) -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"
      integrity="sha512-FDcVY+g7vc5CXANbrTSg1K5qLyriCsGDYCE02Li1tXEYdNQPvLPHNE+rT2Mjei8N7fZbe0WLhw27j2SrGRpdMg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html {
        overflow-x: hidden;
        height: 100%;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100dvh;
        color: #333;
        overflow-x: hidden;
        word-wrap: break-word;
        overscroll-behavior-y: none; /* prevent iOS bounce adding whitespace */
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        position: relative;
        padding: 20px 20px 40px;
      }


      .header {
        text-align: center;
        margin-bottom: 32px;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 16px;
      }
      .header h1 {
        font-size: 2.4em;
        font-weight: 300;
        letter-spacing: -0.5px;
      }
      .sub {
        opacity: 0.9;
        font-size: 0.95em;
        margin-top: 4px;
      }
      .usdc-logo {
        width: 60px;
        height: 60px;
        filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
      }


      .card {
        background: rgba(255, 255, 255, 0.96);
        border-radius: 18px;
        padding: 22px;
        margin-bottom: 22px;
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.12);
        backdrop-filter: blur(10px);
      }


      .wallet-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 14px;
        margin-bottom: 8px;
      }
      .wallet-info {
        flex: 1;
        min-width: 260px;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }


      .wallet-address,
      .network-pill {
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          monospace;
        font-size: 0.9em;
        color: #222;
        background: #eef2ff;
        padding: 8px 12px;
        border-radius: 8px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .wallet-address .copy {
        cursor: pointer;
        opacity: 0.7;
      }
      .wallet-address .copy:hover {
        opacity: 1;
      }


      .balance-container {
        display: flex;
        align-items: baseline;
        gap: 16px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .balance {
        font-size: 1.6em;
        font-weight: 300;
        color: #333;
      }
      .balance span {
        font-weight: 600;
        color: #3e73c4;
      }
      .debit-balance {
        font-size: 1em;
        color: #e74c3c;
        font-weight: 600;
      }
      .credit-balance {
        font-size: 1em;
        color: #27ae60;
        font-weight: 600;
      }
      .net-balance {
        font-size: 1.05em;
        font-weight: 700;
        padding: 8px 12px;
        background: #f8f9fa;
        border-radius: 10px;
      }


      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: 0;
        padding: 11px 18px;
        border-radius: 999px;
        font-size: 0.95em;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.2s ease,
          opacity 0.2s ease;
        box-shadow: 0 4px 14px rgba(102, 126, 234, 0.35);
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.45);
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .btn-outline {
        background: white;
        color: #4f46e5;
        border: 2px solid #c7d2fe;
        box-shadow: none;
        padding: 9px 16px;
        font-weight: 600;
      }
      .btn-danger {
        background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%);
        box-shadow: 0 4px 14px rgba(239, 68, 68, 0.35);
      }
      .btn-muted {
        background: #333;
      }


      .auth-type-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      .auth-type-btn {
        flex: 1;
        min-width: 220px;
        padding: 12px;
        border: 2px solid #e0e0e0;
        background: white;
        border-radius: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
      }
      .auth-type-btn strong {
        display: block;
      }
      .auth-type-btn.selected {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: transparent;
      }
      .auth-type-btn:hover {
        border-color: #667eea;
      }


      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      .form-group {
        margin-bottom: 12px;
      }
      .form-group label {
        display: block;
        margin-bottom: 6px;
        color: #555;
        font-size: 0.92em;
      }
      .form-group input,
      .form-group select {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        font-size: 1em;
        transition: border-color 0.2s ease;
        background: white;
      }
      .form-group input:focus,
      .form-group select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
      }


      .upload-area {
        border: 2px dashed #667eea;
        border-radius: 15px;
        padding: 28px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s ease;
        background: rgba(102, 126, 234, 0.05);
      }
      .upload-area:hover {
        background: rgba(102, 126, 234, 0.1);
        border-color: #764ba2;
      }
      .note {
        font-size: 0.9em;
        color: #666;
      }


      .slips-section {
        margin-bottom: 24px;
      }
      .slips-section h2 {
        color: white;
        margin-bottom: 10px;
        font-weight: 400;
      }
      .slips-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 18px;
      }


      .slip {
        background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
        border-radius: 10px;
        padding: 18px;
        position: relative;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.14);
        transition: transform 0.15s ease, box-shadow 0.2s ease;
        min-height: 260px;
        display: flex;
        flex-direction: column;
      }
      .slip.outgoing {
        background: linear-gradient(135deg, #ffccbc 0%, #ffab91 100%);
      }
      .slip.incoming {
        background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
      }
      .slip:hover {
        transform: translateY(-1px) scale(1.01);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.2);
        z-index: 5;
      }


      .slip .tag {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 0.75em;
        background: rgba(255, 255, 255, 0.85);
        padding: 4px 10px;
        border-radius: 999px;
        font-weight: 600;
      }
      .slip .actions {
        display: flex;
        gap: 8px;
        margin-top: auto;
        align-self: center;
        flex-wrap: wrap;
      }
      .slip .line {
        font-size: 0.86em;
        color: #444;
        margin-bottom: 6px;
        word-break: break-all;
      }
      .slip .title {
        font-size: 1.05em;
        font-weight: 700;
        color: #222;
        margin-bottom: 6px;
      }
      .slip .amount {
        font-size: 1.6em;
        font-weight: 800;
        color: #222;
        margin-bottom: 4px;
      }
      .slip .muted {
        color: #555;
        font-size: 0.8em;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.8em;
        background: #fff;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid #eee;
      }
      .pill.red {
        color: #b91c1c;
        border-color: #fecaca;
        background: #fff1f2;
      }
      .pill.green {
        color: #065f46;
        border-color: #a7f3d0;
        background: #ecfdf5;
      }
      .pill.info {
        color: #1f2937;
        border-color: #e5e7eb;
        background: #f9fafb;
      }


      .delete-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(255, 255, 255, 0.88);
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        cursor: pointer;
        font-size: 1.2em;
        color: #666;
        transition: all 0.2s ease;
      }
      .delete-btn:hover {
        background: rgba(255, 0, 0, 0.18);
        color: #c00;
      }


      #fileInput {
        display: none;
      }


      .paste-panel {
        margin-top: 10px;
        display: block;
      }
      .paste-panel[hidden] {
        display: none !important;
      }


      .status-message {
        position: fixed;
        bottom: 14px;
        right: 14px;
        background: #334155;
        color: white;
        padding: 12px 16px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        display: none;
        animation: slideIn 0.22s ease;
        max-width: 420px;
        z-index: 2000;
        font-size: 0.95em;
      }
      .status-message.success {
        background: #16a34a;
      }
      .status-message.error {
        background: #ef4444;
      }
      .status-message.info {
        background: #334155;
      }


      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }


      .footer {
        text-align: center;
        color: rgba(255, 255, 255, 0.85);
        margin-top: 30px;
        padding: 10px;
        font-size: 0.9em;
      }
      .footer a {
        color: #fff;
        text-decoration: underline;
      }


      .intro-popup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
        animation: fadeIn 0.25s ease;
      }
      .intro-content {
        background: white;
        border-radius: 16px;
        padding: 24px;
        max-width: 700px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }
      .intro-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: #f0f0f0;
        border: 0;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        cursor: pointer;
        font-size: 1.4em;
        transition: all 0.2s ease;
      }
      .intro-close:hover {
        background: #e0e0e0;
        transform: rotate(90deg);
      }
      .intro-content h2 {
        margin-bottom: 8px;
        color: #333;
        font-size: 1.6em;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .intro-section {
        margin: 10px 0;
        padding: 12px;
        background: #f8f9fa;
        border-radius: 10px;
      }
      .intro-section h3 {
        color: #667eea;
        margin-bottom: 6px;
        font-size: 1.02em;
      }
      .intro-steps {
        counter-reset: step;
      }
      .intro-step {
        margin: 6px 0;
        padding-left: 30px;
        position: relative;
        counter-increment: step;
      }
      .intro-step::before {
        content: counter(step);
        position: absolute;
        left: 0;
        top: 0;
        background: #667eea;
        color: white;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.82em;
        font-weight: 700;
      }


      .inline-help {
        font-size: 0.85em;
        color: #4b5563;
        margin-top: 6px;
      }
      .link {
        color: #4f46e5;
        text-decoration: underline;
        cursor: pointer;
      }


      /* ===== Base toggle button (subtle corner toggle) ===== */
      .base-toggle {
        position: fixed;
        top: 12px;
        right: 12px;
        width: 42px;
        height: 42px;
        border-radius: 12px;
        background: #ffffffdd;
        border: 1px solid #e5e7eb;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
        display: grid;
        place-items: center;
        cursor: pointer;
        z-index: 1500;
        transition: transform 0.12s ease, box-shadow 0.2s ease,
          opacity 0.2s ease;
      }
      .base-toggle:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.18);
      }
      .base-toggle svg {
        width: 22px;
        height: 22px;
      }
      .base-toggle.active {
        outline: 2px solid #0052ff;
        outline-offset: 2px;
      }


      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .header {
          flex-direction: column;
        }
        .wallet-header {
          flex-direction: column;
          align-items: stretch;
        }
        .btn,
        .btn-outline {
          width: 100%;
        }
        .slips-container {
          grid-template-columns: 1fr;
        }
        .intro-content {
          padding: 22px 16px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Base mode toggle (click to toggle between Ethereum / Base) -->
    <button
      id="baseToggle"
      class="base-toggle"
      title="Toggle Base network mode"
      aria-pressed="false"
    >
      <!-- Minimal Base 'Square' mark (blue rounded square) -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <rect x="3" y="3" width="18" height="18" rx="4" fill="#0052FF" />
      </svg>
    </button>


    <div class="container">
      <div class="header">
        <svg
          class="usdc-logo"
          viewBox="0 0 32 32"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g fill="none">
            <circle fill="#3E73C4" cx="16" cy="16" r="16" />
            <g fill="#FFF">
              <path
                d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"
              />
              <path
                d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"
              />
            </g>
          </g>
        </svg>
        <div class="usdc-logo" aria-hidden="true"></div>
        <div>
          <h1>IOUSDC 📄🪽</h1>
          <div class="sub">Gasless USDC transfers on Ethereum (EIP-3009)</div>
        </div>
      </div>


      <!-- Wallet -->
      <div class="card">
        <div class="wallet-header">
          <div class="wallet-info">
            <div class="row" style="gap: 8px; margin-bottom: 6px">
              <div
                id="walletAddress"
                class="wallet-address"
                style="display: none"
              >
                <span id="walletAddressText"></span>
                <span
                  class="copy"
                  title="Copy address"
                  onclick="copyFromEl('walletAddressFull')"
                  >📋</span
                >
              </div>
              <div
                id="networkPill"
                class="network-pill"
                style="display: none"
              ></div>
            </div>
            <input
              id="walletAddressFull"
              type="text"
              style="position: absolute; left: -9999px; opacity: 0"
              aria-hidden="true"
            />
            <div class="balance-container">
              <div id="balance" class="balance" style="display: none">
                Balance: <span>0 USDC</span>
              </div>
              <div
                id="debitBalance"
                class="debit-balance"
                style="display: none"
              >
                Debits: -0 USDC
              </div>
              <div
                id="creditBalance"
                class="credit-balance"
                style="display: none"
              >
                Credits: +0 USDC
              </div>
            </div>
            <div
              id="netBalance"
              class="net-balance"
              style="display: none; margin-top: 8px"
            ></div>
          </div>
          <div class="row">
            <button id="connectBtn" class="btn">Connect Wallet</button>
            <button
              id="switchBtn"
              class="btn btn-outline"
              style="display: none"
            >
              Switch to Mainnet
            </button>
            <button
              id="disconnectBtn"
              class="btn btn-danger"
              style="display: none"
            >
              Disconnect
            </button>
          </div>
        </div>
        <div class="inline-help">
          Tip: You can relay someone’s <em>Transfer Authorization</em> even if
          you’re not the recipient.
          <span class="link" onclick="openIntro()">Learn more</span>.
        </div>
      </div>


      <!-- Create -->
      <div id="createSection" class="card" style="display: none">
        <h2 style="margin-bottom: 8px">Create IOU Slip</h2>


        <div
          class="auth-type-selector"
          role="tablist"
          aria-label="Authorization type"
        >
          <button
            class="auth-type-btn selected"
            data-type="transfer"
            aria-selected="true"
          >
            <strong>Transfer Authorization</strong>
            <div style="font-size: 0.85em; opacity: 0.85">
              Anyone can execute
            </div>
          </button>
          <button
            class="auth-type-btn"
            data-type="receive"
            aria-selected="false"
          >
            <strong>Receive Authorization</strong>
            <div style="font-size: 0.85em; opacity: 0.85">
              Only recipient can claim
            </div>
          </button>
        </div>


        <div class="grid">
          <div class="form-group">
            <label for="recipientAddress">Recipient (address or ENS)</label>
            <input
              type="text"
              id="recipientAddress"
              placeholder="0x... or vitalik.eth"
              autocomplete="off"
            />
          </div>
          <div class="form-group">
            <label for="amount">Amount (USDC)</label>
            <input
              type="number"
              id="amount"
              placeholder="100.00"
              inputmode="decimal"
              step="0.000001"
              min="0"
            />
          </div>
        </div>


        <div class="grid">
          <div class="form-group">
            <label for="validDays">Valid for (days)</label>
            <input
              type="number"
              id="validDays"
              placeholder="30"
              value="30"
              min="1"
              max="3650"
            />
          </div>
          <div class="form-group">
            <label for="validAfter"
              >Valid after (optional; seconds from now or UNIX timestamp)</label
            >
            <input
              type="number"
              id="validAfter"
              placeholder="0"
              value="0"
              min="0"
            />
          </div>
        </div>


        <div class="row" style="margin-top: 6px">
          <button id="createSlipBtn" class="btn">Create & Sign IOU</button>
          <button
            id="prefillSelfBtn"
            class="btn btn-outline"
            title="Fill recipient with your address"
          >
            Use My Address
          </button>
        </div>
        <div class="inline-help" id="balanceHint" style="display: none"></div>
      </div>


      <!-- Upload -->
      <div class="card">
        <h2 style="margin-bottom: 8px">Upload IOU Slip</h2>


        <!-- Give the area an ID; remove onclick from the container -->
        <div
          class="upload-area"
          id="uploadArea"
          tabindex="0"
          role="textbox"
          aria-label="Paste IOU JSON here, drag & drop, or browse a file"
        >
          <p>📎 Drag & drop or <strong>paste JSON here</strong></p>
          <button
            id="browseBtn"
            type="button"
            class="btn btn-outline"
            style="margin-top: 8px"
          >
            Browse file…
          </button>
        </div>


        <input
          type="file"
          id="fileInput"
          accept=".json,.txt,application/json,text/plain"
          style="display: none"
        />
      </div>


      <div style="margin-top: 12px">
        <button id="pasteToggleBtn" class="btn btn-outline">
          Paste IOU JSON
        </button>
        <div id="pastePanel" class="paste-panel" hidden>
          <textarea
            id="pasteTextarea"
            rows="8"
            spellcheck="false"
            placeholder="Paste the IOU JSON here…"
            style="
              width: 100%;
              font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
              border: 2px solid #e0e0e0;
              border-radius: 12px;
              padding: 10px;
            "
          ></textarea>
          <div class="row" style="margin-top: 8px">
            <button id="pasteAddBtn" class="btn">Add Slip</button>
            <button id="pasteClearBtn" class="btn btn-outline">Clear</button>
          </div>
        </div>
      </div>


      <!-- Lists -->
      <div
        id="outgoingSlipsSection"
        class="slips-section"
        style="display: none"
      >
        <h2>📤 Your Outstanding IOUs (Debits)</h2>
        <div id="outgoingSlipsContainer" class="slips-container"></div>
      </div>


      <div
        id="incomingSlipsSection"
        class="slips-section"
        style="display: none"
      >
        <h2>📥 Claimable IOUs (Credits)</h2>
        <div id="incomingSlipsContainer" class="slips-container"></div>
      </div>


      <div class="footer">
        <p>
          Made by
          <a href="https://x.com/z0r0zzz" target="_blank" rel="noopener"
            >z0r0z.eth</a
          >.
        </p>
        <p>
          Spec:
          <a
            href="https://eips.ethereum.org/EIPS/eip-3009"
            target="_blank"
            rel="noopener"
            >EIP-3009: Transfer With Authorization</a
          >
          • Contract:
          <a
            href="https://etherscan.io/token/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
            target="_blank"
            rel="noopener"
            >USDC</a
          >
        </p>
      </div>
    </div>


    <!-- Status Toast -->
    <div
      id="statusMessage"
      class="status-message"
      role="status"
      aria-live="polite"
    ></div>


    <!-- Intro Popup -->
    <div id="introPopup" class="intro-popup">
      <div class="intro-content">
        <button class="intro-close" onclick="closeIntro()">×</button>
        <h2>📄🪽 Welcome to IOUSDC</h2>


        <div class="intro-section">
          <h3>🎯 What is this?</h3>
          <p>
            IOUSDC lets you create and share USDC payment authorizations that
            anyone can claim later — without you paying gas. It’s like writing a
            check that the recipient can cash whenever they want.
          </p>
        </div>


        <div class="intro-section">
          <h3>✨ How it works</h3>
          <div class="intro-steps">
            <div class="intro-step">
              Connect your wallet (Ethereum or Base) and see your USDC balance
            </div>
            <div class="intro-step">
              Create an IOU by entering recipient and amount
            </div>
            <div class="intro-step">
              Sign the EIP-712 authorization (no gas!)
            </div>
            <div class="intro-step">
              Download and share the IOU file with recipient
            </div>
            <div class="intro-step">
              Recipient uploads the file and claims USDC on-chain
            </div>
          </div>
        </div>


        <div class="intro-section">
          <h3>🔐 Authorization Types</h3>
          <p>
            <strong>Transfer Authorization:</strong> Anyone with the file can
            execute the transfer for you.
          </p>
          <p>
            <strong>Receive Authorization:</strong> Only the specified recipient
            can claim.
          </p>
        </div>


        <div
          class="intro-section"
          style="background: #fff3cd; border: 1px solid #ffc107"
        >
          <h3>⚡ Important Notes</h3>
          <p>• IOUs expire after your chosen period.</p>
          <p>• Only the claimer pays gas.</p>
          <p>• Once claimed, an IOU cannot be reused.</p>
        </div>


        <button
          class="btn"
          style="width: 100%; margin-top: 6px"
          onclick="closeIntro()"
        >
          Get Started
        </button>
      </div>
    </div>


    <script>
      // --------------------
      // Constants & ABI
      // --------------------
      const ETHEREUM_MAINNET_CHAIN_ID_HEX = "0x1";
      const ETHEREUM_CHAIN_ID = 1;
      const ETHEREUM_USDC_ADDRESS =
        "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";


      // ENS fallback (mainnet) so resolution works even when connected to Base
      const ENS_MAINNET_PROVIDER = new ethers.providers.JsonRpcProvider(
        "https://eth.llamarpc.com"
      );


      // === Base network support (USDC on Base) ===
      const BASE_CHAIN_ID = 8453;
      const BASE_CHAIN_ID_HEX = "0x2105";
      const BASE_USDC_ADDRESS = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
      // Provided reference hashes for Base USDC (for sanity checks only)
      const BASE_DOMAIN_SEPARATOR =
        "0x02fa7265e7c5d81118673727957699e4d68f74cd74b7db77da710fe8a2c7834f";
      const BASE_TYPEHASH_TRANSFER =
        "0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267";
      const BASE_TYPEHASH_RECEIVE =
        "0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8";


      const USDC_DECIMALS = 6;
      const STORAGE_KEY = "usdcSlips_v3";


      // Two network modes: 'ethereum' (default) and 'base'
      let networkMode = "ethereum";


      // EIP-712 domain builders
      function buildDomain(chainId, verifyingContract) {
        return {
          name: "USD Coin",
          version: "2",
          chainId,
          verifyingContract,
        };
      }


      function getActiveConfig() {
        if (networkMode === "base") {
          return {
            chainId: BASE_CHAIN_ID,
            chainIdHex: BASE_CHAIN_ID_HEX,
            usdcAddress: BASE_USDC_ADDRESS,
            label: "Base Mainnet",
            explorerTx: (hash) => `https://basescan.org/tx/${hash}`,
          };
        }
        return {
          chainId: ETHEREUM_CHAIN_ID,
          chainIdHex: ETHEREUM_MAINNET_CHAIN_ID_HEX,
          usdcAddress: ETHEREUM_USDC_ADDRESS,
          label: "Ethereum Mainnet",
          explorerTx: (hash) => `https://etherscan.io/tx/${hash}`,
        };
      }


      // Active domain & address (kept mutable so existing calls keep working)
      let USDC_ADDRESS = ETHEREUM_USDC_ADDRESS;
      let domain = buildDomain(ETHEREUM_CHAIN_ID, ETHEREUM_USDC_ADDRESS);


      const USDC_ABI = [
        "function balanceOf(address owner) view returns (uint256)",
        "function transferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce,uint8 v,bytes32 r,bytes32 s)",
        "function receiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce,uint8 v,bytes32 r,bytes32 s)",
        "function cancelAuthorization(address authorizer,bytes32 nonce,uint8 v,bytes32 r,bytes32 s)",
        "function authorizationState(address authorizer,bytes32 nonce) view returns (bool)",
      ];


      // EIP-712 types (USDC v2)
      const TYPES = {
        TransferWithAuthorization: [
          { name: "from", type: "address" },
          { name: "to", type: "address" },
          { name: "value", type: "uint256" },
          { name: "validAfter", type: "uint256" },
          { name: "validBefore", type: "uint256" },
          { name: "nonce", type: "bytes32" },
        ],
        ReceiveWithAuthorization: [
          { name: "from", type: "address" },
          { name: "to", type: "address" },
          { name: "value", type: "uint256" },
          { name: "validAfter", type: "uint256" },
          { name: "validBefore", type: "uint256" },
          { name: "nonce", type: "bytes32" },
        ],
        CancelAuthorization: [
          { name: "authorizer", type: "address" },
          { name: "nonce", type: "bytes32" },
        ],
      };


      // EIP-712 wrapper for cancel typed data
      const CANCEL_TYPES = { CancelAuthorization: TYPES.CancelAuthorization };


      // --------------------
      // State
      // --------------------
      let provider,
        signer,
        usdc,
        account = null,
        chainId = ETHEREUM_CHAIN_ID; // will track connected network id
      let slips = []; // local list of uploaded/created slips
      let selectedAuthType = "transfer";
      let isConnecting = false;


      // --------------------
      // Helpers
      // --------------------
      const $ = (id) => document.getElementById(id);


      function showStatus(message, type = "info") {
        const statusEl = $("statusMessage");
        statusEl.textContent = message;
        statusEl.className = `status-message ${type}`;
        statusEl.style.display = "block";
        clearTimeout(showStatus._t);
        showStatus._t = setTimeout(
          () => (statusEl.style.display = "none"),
          5200
        );
      }


      function copyFromEl(inputId) {
        const el = $(inputId);
        el.select();
        el.setSelectionRange(0, 99999);
        document.execCommand("copy");
        showStatus("Copied to clipboard", "success");
      }


      function shortAddr(addr) {
        return addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : "";
      }


      function clampUSDCDecimals(str) {
        if (!str || isNaN(Number(str))) return null;
        const [i, f = ""] = String(str).split(".");
        return f.length > USDC_DECIMALS
          ? `${i}.${f.slice(0, USDC_DECIMALS)}`
          : String(str);
      }


      function slipLocalId(from, nonce) {
        return `${from.toLowerCase()}_${nonce.toLowerCase()}`;
      }


      function isExpired(slip) {
        return Math.floor(Date.now() / 1000) > Number(slip.validBefore);
      }


      function extractSlipFromText(raw) {
        let text = String(raw || "").trim();


        // Strip code fences like ```json ... ```
        if (text.startsWith("```")) {
          text = text
            .replace(/^```[a-zA-Z]*\s*/, "")
            .replace(/```$/, "")
            .trim();
        }


        // First, try as-is
        try {
          return JSON.parse(text);
        } catch {}


        // Then try to find the first {...} block in messages
        const first = text.indexOf("{");
        const last = text.lastIndexOf("}");
        if (first !== -1 && last !== -1 && last > first) {
          const maybe = text.slice(first, last + 1);
          try {
            return JSON.parse(maybe);
          } catch {}
        }


        throw new Error("No valid JSON found");
      }


      async function addSlipFromText(raw) {
        try {
          const slip = extractSlipFromText(raw);
          validateSlipShape(slip);


          // Off-chain signature sanity (try to recover with both domains if needed)
          try {
            const types =
              slip.type === "receive"
                ? { ReceiveWithAuthorization: TYPES.ReceiveWithAuthorization }
                : {
                    TransferWithAuthorization: TYPES.TransferWithAuthorization,
                  };


            const message = {
              from: slip.from,
              to: slip.to,
              value: slip.value,
              validAfter: String(slip.validAfter),
              validBefore: String(slip.validBefore),
              nonce: slip.nonce,
            };


            const tryDomains = [];
            if (slip.chainId === ETHEREUM_CHAIN_ID) {
              tryDomains.push(
                buildDomain(ETHEREUM_CHAIN_ID, ETHEREUM_USDC_ADDRESS)
              );
            } else if (slip.chainId === BASE_CHAIN_ID) {
              tryDomains.push(buildDomain(BASE_CHAIN_ID, BASE_USDC_ADDRESS));
            } else {
              // Unknown or missing chainId: try both
              tryDomains.push(
                buildDomain(ETHEREUM_CHAIN_ID, ETHEREUM_USDC_ADDRESS),
                buildDomain(BASE_CHAIN_ID, BASE_USDC_ADDRESS)
              );
            }


            let ok = false;
            for (const dom of tryDomains) {
              try {
                const recovered = ethers.utils.verifyTypedData(
                  dom,
                  types,
                  message,
                  slip.signature
                );
                if (recovered.toLowerCase() === slip.from.toLowerCase()) {
                  ok = true;
                  break;
                }
              } catch {}
            }
            if (!ok) {
              showStatus(
                "Signature does not match 'from' address (check network/domain).",
                "error"
              );
              return;
            }
          } catch (_) {
            /* fine if not connected */
          }


          const id = slipLocalId(slip.from, slip.nonce);
          if (!slips.some((s) => slipLocalId(s.from, s.nonce) === id)) {
            slips.push(slip);
            saveSlips();
          }
          renderSlips();
          updateBalances();
          showStatus("IOU slip added from pasted text.", "success");
        } catch (err) {
          showStatus(
            "Could not parse IOU JSON: " + (err?.message || err),
            "error"
          );
        }
      }


      function isUserRejected(err) {
        const c = err?.code;
        const m = String(err?.message || "").toLowerCase();
        // MetaMask/EIP-1193: 4001; ethers sometimes: 'ACTION_REJECTED'
        return (
          c === 4001 ||
          c === "ACTION_REJECTED" ||
          m.includes("user rejected") ||
          m.includes("denied") ||
          m.includes("rejected")
        );
      }


      // --------------------
      // Storage (graceful)
      // --------------------
      function loadSlips() {
        try {
          const stored =
            localStorage.getItem(STORAGE_KEY) ||
            localStorage.getItem("usdcSlips") ||
            "[]";
          const parsed = JSON.parse(stored);
          slips = Array.isArray(parsed) ? parsed : [];
          // dedupe by from+nonce
          const seen = new Set();
          slips = slips.filter((s) => {
            if (!s?.from || !s?.nonce) return false;
            const id = slipLocalId(s.from, s.nonce);
            if (seen.has(id)) return false;
            seen.add(id);
            return true;
          });
        } catch (_) {
          slips = [];
        }
        renderSlips();
        updateBalances();
      }


      function saveSlips() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(slips));
        } catch (_) {
          /* ignore quota errors */
        }
      }


      // --------------------
      // Network Mode & Wallet
      // --------------------
      function bindUsdcContract() {
        if (!provider) return;
        const runner = signer || provider;
        usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, runner);
      }


      function updateModeUi(onCorrectNetwork) {
        $("switchBtn").textContent =
          "Switch to " + (networkMode === "base" ? "Base" : "Mainnet");
        $("networkPill").style.display = "inline-flex";
        $("networkPill").textContent = onCorrectNetwork
          ? networkMode === "base"
            ? "Base Mainnet"
            : "Ethereum Mainnet"
          : `Wrong network (Chain ID ${chainId})`;
        $("baseToggle").classList.toggle("active", networkMode === "base");
        $("baseToggle").setAttribute(
          "aria-pressed",
          networkMode === "base" ? "true" : "false"
        );
      }


      function setNetworkMode(mode, { silent = false } = {}) {
        networkMode = mode === "base" ? "base" : "ethereum";
        const cfg = getActiveConfig();
        USDC_ADDRESS = cfg.usdcAddress;
        domain = buildDomain(cfg.chainId, cfg.usdcAddress);
        bindUsdcContract();
        if (!silent) {
          // If connected, reflect correct/incorrect state
          if (provider) {
            ensureCorrectNetwork(true);
          }
        }
      }


      async function ensureCorrectNetwork(updateUI = true) {
        try {
          const net = await provider.getNetwork();
          chainId = net.chainId;
          const cfg = getActiveConfig();
          const onCorrect = chainId === cfg.chainId;
          if (updateUI) {
            $("switchBtn").style.display = onCorrect ? "none" : "inline-block";
            updateModeUi(onCorrect);
          }
          return onCorrect;
        } catch {
          return false;
        }
      }


      async function switchToCorrectNetwork() {
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: getActiveConfig().chainIdHex }],
          });
          showStatus(`Switched to ${getActiveConfig().label}`, "success");
          await postConnectSetup();
        } catch {
          showStatus(
            `Please switch to ${getActiveConfig().label} in your wallet`,
            "error"
          );
        }
      }


      async function connectWallet() {
        if (isConnecting) return;
        isConnecting = true;
        try {
          if (!window.ethereum) {
            showStatus(
              "Please install MetaMask or a compatible wallet.",
              "error"
            );
            isConnecting = false;
            return;
          }
          provider = new ethers.providers.Web3Provider(window.ethereum, "any");


          // Request accounts FIRST to avoid "unknown account #0"
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });
          if (!accounts || !accounts.length) {
            showStatus("No account authorized.", "error");
            isConnecting = false;
            return;
          }


          // Bind signer directly to the returned address
          const addr = ethers.utils.getAddress(accounts[0]);
          signer = provider.getSigner(addr);
          account = addr;


          // Autodetect current chain and align mode (ETH vs Base)
          try {
            const net = await provider.getNetwork();
            chainId = net.chainId;
            if (chainId === BASE_CHAIN_ID) {
              setNetworkMode("base", { silent: true });
            } else {
              setNetworkMode("ethereum", { silent: true });
            }
          } catch {}


          bindUsdcContract();
          await postConnectSetup(true);
        } catch (err) {
          console.error(err);
          showStatus(err?.message || "Failed to connect wallet", "error");
        } finally {
          isConnecting = false;
        }
      }


      async function postConnectSetup(firstConnect = false) {
        const onCorrect = await ensureCorrectNetwork(true);


        $("walletAddressText").textContent = shortAddr(account);
        $("walletAddressFull").value = account;
        $("walletAddress").style.display = "inline-flex";
        $("connectBtn").style.display = "none";
        $("disconnectBtn").style.display = "inline-block";
        $("createSection").style.display = "block";


        await updateBalance();
        updateBalances();
        renderSlips(); // refresh sticky notes context


        if (!onCorrect) {
          showStatus(
            `You're not on ${
              getActiveConfig().label
            }. Actions are limited until you switch.`,
            "error"
          );
        } else if (firstConnect) {
          showStatus("Wallet connected successfully!", "success");
        }
      }


      function disconnectWallet() {
        account = signer = provider = usdc = null;
        $("walletAddress").style.display = "none";
        $("balance").style.display = "none";
        $("debitBalance").style.display = "none";
        $("creditBalance").style.display = "none";
        $("netBalance").style.display = "none";
        $("connectBtn").style.display = "inline-block";
        $("switchBtn").style.display = "none";
        $("disconnectBtn").style.display = "none";
        $("createSection").style.display = "none";
        $("networkPill").style.display = "none";
        renderSlips(); // re-render with neutral sticky notes
        showStatus("Wallet disconnected", "info");
      }


      async function updateBalance() {
        if (!usdc || !account) return;
        try {
          const bal = await usdc.balanceOf(account);
          const formatted = ethers.utils.formatUnits(bal, USDC_DECIMALS);
          $("balance").querySelector("span").textContent = `${Number(
            formatted
          ).toFixed(2)} USDC`;
          $("balance").style.display = "block";
          $("balanceHint").style.display = "block";
          $("balanceHint").textContent = `Your USDC balance: ${Number(
            formatted
          ).toLocaleString(undefined, { maximumFractionDigits: 6 })}`;
        } catch (e) {
          console.error(e);
        }
      }


      // Auto-connect silently if already authorized
      async function tryAutoconnect() {
        try {
          if (!window.ethereum) return;
          const accounts = await window.ethereum.request({
            method: "eth_accounts",
          });
          if (accounts && accounts.length) {
            provider = new ethers.providers.Web3Provider(
              window.ethereum,
              "any"
            );
            const addr = ethers.utils.getAddress(accounts[0]);
            signer = provider.getSigner(addr);
            account = addr;


            // Align mode with current chain
            const net = await provider.getNetwork();
            chainId = net.chainId;
            if (chainId === BASE_CHAIN_ID) {
              setNetworkMode("base", { silent: true });
            } else {
              setNetworkMode("ethereum", { silent: true });
            }


            bindUsdcContract();
            await postConnectSetup(false);
          }
        } catch {}
      }


      // --------------------
      // Balances & Lists
      // --------------------
      function updateBalances() {
        if (!account) return;
        let totalDebit = 0,
          totalCredit = 0;
        slips.forEach((slip) => {
          const amt = parseFloat(
            slip.amount || ethers.utils.formatUnits(slip.value, USDC_DECIMALS)
          );
          if (slip.from?.toLowerCase() === account.toLowerCase())
            totalDebit += amt;
          if (slip.to?.toLowerCase() === account.toLowerCase())
            totalCredit += amt;
        });
        if (totalDebit > 0) {
          $("debitBalance").textContent = `Debits: -${totalDebit.toFixed(
            2
          )} USDC`;
          $("debitBalance").style.display = "block";
        } else $("debitBalance").style.display = "none";


        if (totalCredit > 0) {
          $("creditBalance").textContent = `Credits: +${totalCredit.toFixed(
            2
          )} USDC`;
          $("creditBalance").style.display = "block";
        } else $("creditBalance").style.display = "none";


        const net = totalCredit - totalDebit;
        if (totalDebit > 0 || totalCredit > 0) {
          const el = $("netBalance");
          el.innerHTML = `Net Position: <strong style="color:${
            net >= 0 ? "#27ae60" : "#e74c3c"
          }">${net >= 0 ? "+" : ""}${net.toFixed(2)} USDC</strong>`;
          el.style.display = "inline-block";
        } else $("netBalance").style.display = "none";
      }


      function renderSlips() {
        const outgoingContainer = $("outgoingSlipsContainer");
        const incomingContainer = $("incomingSlipsContainer");
        const outgoingSection = $("outgoingSlipsSection");
        const incomingSection = $("incomingSlipsSection");
        outgoingContainer.innerHTML = "";
        incomingContainer.innerHTML = "";


        const outgoing = [],
          incoming = [];
        slips
          .slice()
          .sort((a, b) => Number(a.validBefore) - Number(b.validBefore))
          .forEach((slip) => {
            const mineFrom =
              account && slip.from?.toLowerCase() === account.toLowerCase();
            if (mineFrom) outgoing.push(slip);
            else incoming.push(slip); // includes recipient case and others
          });


        outgoingSection.style.display = outgoing.length ? "block" : "none";
        incomingSection.style.display = incoming.length ? "block" : "none";


        outgoing.forEach((s) => renderSlip(s, outgoingContainer, "outgoing"));
        incoming.forEach((s) => renderSlip(s, incomingContainer, "incoming"));
      }


      function renderSlip(slip, container, type) {
        const el = document.createElement("div");
        el.className = `slip ${type}`;


        const validUntil = new Date(
          Number(slip.validBefore) * 1000
        ).toLocaleString();
        const amount =
          slip.amount || ethers.utils.formatUnits(slip.value, USDC_DECIMALS);
        const slipType = slip.type === "receive" ? "receive" : "transfer";
        const isOwn =
          account && slip.from?.toLowerCase() === account.toLowerCase();
        const isRecipient =
          account && slip.to?.toLowerCase() === account.toLowerCase();
        const canClaim =
          !!account && (slipType === "transfer" ? true : isRecipient);
        const expired = isExpired(slip);


        // Permission sticky
        let permissionPill = `<span class="pill info">Viewer</span>`;
        if (isOwn)
          permissionPill = `<span class="pill red">You are the Sender</span>`;
        else if (isRecipient)
          permissionPill = `<span class="pill green">You are the Recipient</span>`;


        // Claim button label based on context
        const claimLabel =
          slipType === "receive" ? "Claim" : "Execute Transfer";


        const debitCreditPill =
          type === "outgoing"
            ? `<span class="pill red">Debit −${Number(amount).toFixed(
                2
              )} USDC</span>`
            : `<span class="pill green">Credit +${Number(amount).toFixed(
                2
              )} USDC</span>`;


        const tag =
          slipType === "receive"
            ? "Receive Authorization"
            : "Transfer Authorization";


        el.innerHTML = `
          <span class="tag">${tag}</span>
          <button class="delete-btn" title="Remove from local list" onclick="deleteSlip('${slipLocalId(
            slip.from,
            slip.nonce
          )}')">×</button>
          <div class="title">${shortAddr(slip.from)} → ${shortAddr(
          slip.to
        )}</div>
          <div class="amount">${Number(amount).toLocaleString(undefined, {
            maximumFractionDigits: 6,
          })} USDC</div>
          <div class="line"><strong>From:</strong> ${slip.from}</div>
          <div class="line"><strong>To:</strong> ${slip.to}</div>
          <div class="line"><strong>Valid until:</strong> ${validUntil} ${
          expired ? "⛔️ (expired)" : ""
        }</div>
          <div class="line muted">${
            slipType === "receive"
              ? "Only recipient can claim"
              : "Anyone can execute"
          }</div>
          <div style="margin:8px 0; display:flex; gap:6px; flex-wrap:wrap">
            ${debitCreditPill}
            <span class="pill">Nonce: ${slip.nonce.slice(0, 10)}…</span>
            ${permissionPill}
          </div>
          <div class="actions">
            <button class="btn btn-muted" onclick="downloadSlip('${slipLocalId(
              slip.from,
              slip.nonce
            )}')">Download</button>
            <button class="btn btn-outline" onclick="copySlip('${slipLocalId(
              slip.from,
              slip.nonce
            )}')">Copy JSON</button>
            <button class="btn" ${
              canClaim && !expired ? "" : "disabled"
            } title="${
          !canClaim
            ? isOwn
              ? "You are the sender"
              : "Not claimable by this account"
            : expired
            ? "Expired"
            : ""
        }" onclick="claimSlip('${slipLocalId(
          slip.from,
          slip.nonce
        )}')">${claimLabel}</button>
            <button class="btn btn-outline" onclick="checkStatus('${slipLocalId(
              slip.from,
              slip.nonce
            )}')">Check Status</button>
            ${
              isOwn
                ? `<button class="btn btn-danger" ${
                    expired ? "disabled" : ""
                  } onclick="revokeSlip('${slipLocalId(
                    slip.from,
                    slip.nonce
                  )}')">Revoke</button>`
                : ""
            }
          </div>
        `;
        container.appendChild(el);
      }


      // --------------------
      // Creating Slips (signing: strict USDC EIP-712)
      // --------------------
      async function createSlip() {
        try {
          if (!signer || !provider)
            throw new Error("Connect your wallet first");
          const onCorrect = await ensureCorrectNetwork();
          if (!onCorrect) {
            showStatus(`Please switch to ${getActiveConfig().label}`, "error");
            return;
          }


          const resolved = await normalizeRecipient(
            $("recipientAddress").value,
            provider
          );
          if (!resolved) {
            showStatus("Invalid recipient address / ENS", "error");
            return;
          }
          const recipient = resolved.address; // checksummed address


          let amountStr = clampUSDCDecimals($("amount").value);
          if (!amountStr || Number(amountStr) <= 0) {
            showStatus("Invalid amount", "error");
            return;
          }
          const validDays = parseInt($("validDays").value || "0", 10);
          if (!Number.isFinite(validDays) || validDays <= 0) {
            showStatus("Enter a valid number of days > 0", "error");
            return;
          }


          const value = ethers.utils.parseUnits(amountStr, USDC_DECIMALS);
          const now = Math.floor(Date.now() / 1000);
          const raw = String($("validAfter").value || "").trim();


          let validAfter = 0;
          if (raw !== "" && Number(raw) > 0) {
            const n = Number(raw);
            if (n >= 1e12) {
              // ms since epoch
              validAfter = Math.max(0, Math.floor(n / 1000) - 60);
            } else if (n > 1e9) {
              // sec since epoch
              validAfter = Math.max(0, Math.floor(n) - 60);
            } else {
              // delta seconds from now
              validAfter = now + Math.floor(n); // no nudge for deltas
            }
          }


          const validBefore = now + validDays * 86400;
          if (validBefore <= validAfter) {
            showStatus(
              "'Valid until' must be later than 'Valid after'",
              "error"
            );
            return;
          }


          const from = account; // already checksummed
          const nonce = ethers.utils.hexlify(ethers.utils.randomBytes(32));
          const useReceive = selectedAuthType === "receive";


          const message = {
            from: from, // 0x…
            to: recipient, // 0x…
            value: value.toString(), // "1000000"
            validAfter: String(validAfter), // "0" or "1712345678"
            validBefore: String(validBefore), // "1715945678"
            nonce: nonce, // 0x…32 bytes
          };
          const types = useReceive
            ? { ReceiveWithAuthorization: TYPES.ReceiveWithAuthorization }
            : { TransferWithAuthorization: TYPES.TransferWithAuthorization };


          // Pre-flight balance info (not a blocker for EIP-3009)
          try {
            const currentBal = await usdc.balanceOf(from);
            if (currentBal.lt(value)) {
              showStatus(
                "Heads-up: Your USDC balance is currently lower than this IOU amount. The claim will fail unless you top up before it’s claimed.",
                "info"
              );
            }
          } catch (_) {}


          // Strict EIP-712 signing against active domain (ETH or Base)
          let signature;
          try {
            signature = await signer._signTypedData(domain, types, message);
          } catch (err) {
            if (isUserRejected(err)) {
              showStatus("Signature request canceled.", "info");
              return; // exit cleanly, no scary error
            }
            throw err; // bubble up unexpected errors
          }
          const { v, r, s } = ethers.utils.splitSignature(signature);


          const cfg = getActiveConfig();


          const slip = {
            type: useReceive ? "receive" : "transfer",
            from,
            to: recipient, // checksummed address
            value: value.toString(), // base units
            validAfter, // seconds
            validBefore, // seconds
            nonce,
            v,
            r,
            s,
            amount: amountStr, // human amount string
            signature,
            created: new Date().toISOString(),
            chainId: cfg.chainId,
          };


          // Store locally (dedupe)
          const id = slipLocalId(from, nonce);
          if (!slips.some((s) => slipLocalId(s.from, s.nonce) === id)) {
            slips.push(slip);
            saveSlips();
          }
          renderSlips();
          updateBalances();


          await downloadObjectAsFile(
            slip,
            `usdc-iou-${useReceive ? "receive" : "transfer"}-${Date.now()}.json`
          );
          showStatus(
            `IOU created (${
              useReceive ? "Receive" : "Transfer"
            } authorization) and downloaded.`,
            "success"
          );


          // Clear form
          $("recipientAddress").value = "";
          $("amount").value = "";
          $("validDays").value = "30";
          $("validAfter").value = "0";
        } catch (err) {
          console.error("createSlip error:", err);
          showStatus(`Failed to create IOU: ${err?.message || err}`, "error");
        }
      }


      async function normalizeRecipient(input, provider) {
        const raw = String(input || "").trim();
        if (!raw) return null;


        if (ethers.utils.isAddress(raw)) {
          return { address: ethers.utils.getAddress(raw), display: raw };
        }


        const isENS = /\.eth$/i.test(raw);
        let resolved = null;


        // 👉 If it's clearly ENS, resolve on mainnet first
        if (isENS) {
          try {
            resolved = await ENS_MAINNET_PROVIDER.resolveName(raw);
          } catch {}
        } else {
          try {
            resolved = await provider.resolveName(raw);
          } catch {}
          if (!resolved) {
            try {
              resolved = await ENS_MAINNET_PROVIDER.resolveName(raw);
            } catch {}
          }
        }


        if (!resolved || !ethers.utils.isAddress(resolved)) return null;
        return { address: ethers.utils.getAddress(resolved), display: raw };
      }


      // --------------------
      // Upload / Download / Copy
      // --------------------
      function handleFileUpload(ev) {
        // Support both <input type="file"> and drag/drop events
        const file = ev?.target?.files?.[0] || ev?.dataTransfer?.files?.[0];


        if (!file) return;


        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const txt = String(e.target?.result || "");
            const slip = JSON.parse(txt);


            validateSlipShape(slip);


            // Off-chain signature sanity: try ETH then Base domains if needed
            try {
              const types =
                slip.type === "receive"
                  ? { ReceiveWithAuthorization: TYPES.ReceiveWithAuthorization }
                  : {
                      TransferWithAuthorization:
                        TYPES.TransferWithAuthorization,
                    };


              const message = {
                from: slip.from,
                to: slip.to,
                value: slip.value,
                validAfter: String(slip.validAfter),
                validBefore: String(slip.validBefore),
                nonce: slip.nonce,
              };


              const tryDomains = [];
              if (slip.chainId === ETHEREUM_CHAIN_ID) {
                tryDomains.push(
                  buildDomain(ETHEREUM_CHAIN_ID, ETHEREUM_USDC_ADDRESS)
                );
              } else if (slip.chainId === BASE_CHAIN_ID) {
                tryDomains.push(buildDomain(BASE_CHAIN_ID, BASE_USDC_ADDRESS));
              } else {
                tryDomains.push(
                  buildDomain(ETHEREUM_CHAIN_ID, ETHEREUM_USDC_ADDRESS),
                  buildDomain(BASE_CHAIN_ID, BASE_USDC_ADDRESS)
                );
              }


              let ok = false;
              for (const dom of tryDomains) {
                try {
                  const recovered = ethers.utils.verifyTypedData(
                    dom,
                    types,
                    message,
                    slip.signature
                  );
                  if (recovered.toLowerCase() === slip.from.toLowerCase()) {
                    ok = true;
                    break;
                  }
                } catch {}
              }


              if (!ok) {
                showStatus(
                  "Signature does not match 'from' address (check network/domain).",
                  "error"
                );
                return;
              }
            } catch (_) {
              // Fine if not connected
            }


            const id = slipLocalId(slip.from, slip.nonce);
            if (!slips.some((s) => slipLocalId(s.from, s.nonce) === id)) {
              slips.push(slip);
              saveSlips();
            }


            renderSlips();
            updateBalances();
            showStatus("IOU slip added.", "success");


            // Clear the <input> value if this came from a file input
            if (ev?.target && "value" in ev.target) ev.target.value = "";
          } catch (err) {
            console.error(err);
            showStatus(
              "Invalid IOU file. Ensure it's a JSON/TXT exported by this app.",
              "error"
            );
          }
        };


        reader.readAsText(file);
      }


      function validateSlipShape(slip) {
        if (!slip || typeof slip !== "object") {
          throw new Error("Invalid slip: expected an object");
        }


        // Required fields
        const required = [
          "from",
          "to",
          "value",
          "validAfter",
          "validBefore",
          "nonce",
          "v",
          "r",
          "s",
          "signature",
        ];
        for (const k of required) {
          if (slip[k] === undefined || slip[k] === null) {
            throw new Error(`Missing field: ${k}`);
          }
        }


        // Normalize & validate addresses (checksum)
        try {
          slip.from = ethers.utils.getAddress(slip.from);
        } catch {
          throw new Error("Invalid from address");
        }
        try {
          slip.to = ethers.utils.getAddress(slip.to);
        } catch {
          throw new Error("Invalid to address");
        }


        // Normalize & validate nonce (bytes32)
        if (typeof slip.nonce !== "string")
          slip.nonce = String(slip.nonce || "");
        if (!/^0x[0-9a-fA-F]+$/.test(slip.nonce))
          throw new Error("Invalid nonce");
        try {
          slip.nonce = ethers.utils.hexZeroPad(slip.nonce, 32);
        } catch {
          throw new Error("Invalid nonce (must be <= 32 bytes hex)");
        }


        // Normalize & validate r/s (bytes32 each)
        for (const field of ["r", "s"]) {
          if (typeof slip[field] !== "string")
            slip[field] = String(slip[field] || "");
          if (!/^0x[0-9a-fA-F]+$/.test(slip[field]))
            throw new Error(`Invalid ${field}`);
          try {
            slip[field] = ethers.utils.hexZeroPad(slip[field], 32);
          } catch {
            throw new Error(`Invalid ${field} (must be 32 bytes hex)`);
          }
        }


        // Normalize & validate v (27/28; accept 0/1 and hex)
        let vNum = Number(slip.v);
        if (!Number.isFinite(vNum)) throw new Error("Invalid v");
        if (vNum === 0 || vNum === 1) vNum += 27;
        if (vNum !== 27 && vNum !== 28)
          throw new Error("Invalid v (expected 27 or 28)");
        slip.v = vNum;


        // Normalize value to a base-units decimal string (non-negative integer)
        try {
          const bn = ethers.BigNumber.from(slip.value);
          if (bn.lt(0)) throw new Error();
          slip.value = bn.toString();
        } catch {
          throw new Error("Invalid value; expected integer base units");
        }


        // Normalize times (integers, >= 0). Allow expired/ill-ordered slips; UI handles it.
        const toIntSec = (x, label) => {
          const n = Number(String(x));
          if (!Number.isFinite(n) || n < 0) throw new Error(`Invalid ${label}`);
          return Math.floor(n);
        };
        slip.validAfter = toIntSec(slip.validAfter, "validAfter");
        slip.validBefore = toIntSec(slip.validBefore, "validBefore");


        // Normalize type
        slip.type = slip.type === "receive" ? "receive" : "transfer";


        // Canonicalize signature to match (v,r,s)
        try {
          slip.signature = ethers.utils.joinSignature({
            v: slip.v,
            r: slip.r,
            s: slip.s,
          });
        } catch {
          throw new Error("Invalid signature fields (v/r/s)");
        }


        // (Optional) Keep chainId if present; else leave undefined.
        if (slip.chainId !== undefined) {
          const cid = Number(slip.chainId);
          if (Number.isFinite(cid)) slip.chainId = cid;
          else delete slip.chainId;
        }


        return slip;
      }


      async function downloadObjectAsFile(obj, filename) {
        const data = JSON.stringify(obj, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }


      function downloadSlip(localId) {
        const slip = slips.find(
          (s) => slipLocalId(s.from, s.nonce) === localId
        );
        if (!slip) return;
        downloadObjectAsFile(
          { ...slip },
          `usdc-iou-${slip.type}-${Date.now()}.json`
        );
      }


      function copySlip(localId) {
        const slip = slips.find(
          (s) => slipLocalId(s.from, s.nonce) === localId
        );
        if (!slip) return;
        const text = JSON.stringify(slip, null, 2);
        navigator.clipboard?.writeText(text).then(
          () => showStatus("IOU JSON copied to clipboard", "success"),
          () => {
            const ta = document.createElement("textarea");
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            showStatus("IOU JSON copied", "success");
          }
        );
      }


      function deleteSlip(localId) {
        slips = slips.filter((s) => slipLocalId(s.from, s.nonce) !== localId);
        saveSlips();
        renderSlips();
        updateBalances();
        showStatus("Removed from local list.", "success");
      }


      // --------------------
      // Claiming, Status & Revoking
      // --------------------
      async function checkStatus(localId) {
        try {
          if (!provider || !usdc)
            throw new Error("Connect your wallet to check status.");
          const slip = slips.find(
            (s) => slipLocalId(s.from, s.nonce) === localId
          );
          if (!slip) return;


          const net = await provider.getNetwork();
          if (slip.chainId && net.chainId !== slip.chainId) {
            showStatus(
              `Please switch to ${
                slip.chainId === BASE_CHAIN_ID
                  ? "Base Mainnet"
                  : "Ethereum Mainnet"
              } to check this authorization.`,
              "error"
            );
            return;
          }


          const used = await usdc.authorizationState(slip.from, slip.nonce);
          if (used) {
            showStatus("This authorization is already used.", "error");
            return;
          }
          if (isExpired(slip)) {
            showStatus("This authorization is expired.", "error");
            return;
          }
          showStatus("Authorization appears unused and valid.", "success");
        } catch (err) {
          console.error(err);
          showStatus(
            `Status check failed: ${err?.reason || err?.message || err}`,
            "error"
          );
        }
      }


      async function claimSlip(localId) {
        const slip = slips.find(
          (s) => slipLocalId(s.from, s.nonce) === localId
        );
        if (!slip) return;
        try {
          if (!signer) throw new Error("Please connect your wallet");


          // Ensure we are on the chain the slip was signed for
          const net = await provider.getNetwork();
          if (slip.chainId && net.chainId !== slip.chainId) {
            showStatus(
              `Please switch to ${
                slip.chainId === BASE_CHAIN_ID
                  ? "Base Mainnet"
                  : "Ethereum Mainnet"
              } to claim this IOU.`,
              "error"
            );
            return;
          }


          // Also ensure active app mode matches (keeps domain/contract consistent)
          if (slip.chainId === BASE_CHAIN_ID && networkMode !== "base") {
            setNetworkMode("base");
          } else if (
            slip.chainId === ETHEREUM_CHAIN_ID &&
            networkMode !== "ethereum"
          ) {
            setNetworkMode("ethereum");
          }


          const used = await usdc.authorizationState(slip.from, slip.nonce);
          if (used) {
            showStatus("This IOU has already been claimed", "error");
            deleteSlip(localId);
            return;
          }
          if (isExpired(slip)) {
            showStatus("This IOU has expired", "error");
            return;
          }


          let tx;
          if (slip.type === "receive") {
            if (account.toLowerCase() !== slip.to.toLowerCase()) {
              showStatus(
                "Only the designated recipient can claim this IOU.",
                "error"
              );
              return;
            }
            const est = await usdc.estimateGas
              .receiveWithAuthorization(
                slip.from,
                slip.to,
                slip.value,
                slip.validAfter,
                slip.validBefore,
                slip.nonce,
                slip.v,
                slip.r,
                slip.s
              )
              .catch(() => ethers.BigNumber.from("150000"));
            tx = await usdc.receiveWithAuthorization(
              slip.from,
              slip.to,
              slip.value,
              slip.validAfter,
              slip.validBefore,
              slip.nonce,
              slip.v,
              slip.r,
              slip.s,
              { gasLimit: est.mul(120).div(100) }
            );
          } else {
            const est = await usdc.estimateGas
              .transferWithAuthorization(
                slip.from,
                slip.to,
                slip.value,
                slip.validAfter,
                slip.validBefore,
                slip.nonce,
                slip.v,
                slip.r,
                slip.s
              )
              .catch(() => ethers.BigNumber.from("150000"));
            tx = await usdc.transferWithAuthorization(
              slip.from,
              slip.to,
              slip.value,
              slip.validAfter,
              slip.validBefore,
              slip.nonce,
              slip.v,
              slip.r,
              slip.s,
              { gasLimit: est.mul(120).div(100) }
            );
          }
          showStatus("Submitting claim…", "info");
          const receipt = await tx.wait();
          deleteSlip(localId);
          await updateBalance();
          const explorerTx =
            slip.chainId === BASE_CHAIN_ID
              ? `https://basescan.org/tx/${receipt.transactionHash}`
              : `https://etherscan.io/tx/${receipt.transactionHash}`;
          showStatus(`Claimed! View on explorer: ${explorerTx}`, "success");
        } catch (err) {
          console.error("claimSlip:", err);
          const msg =
            err?.error?.message ||
            err?.reason ||
            err?.message ||
            "Unknown error";


          if (
            isUserRejected(err) ||
            /user rejected|transaction was rejected|denied/i.test(msg)
          ) {
            showStatus("Transaction canceled.", "info");
            return;
          }


          if (msg.includes("authorization is used")) {
            showStatus("This IOU has already been claimed", "error");
            deleteSlip(localId);
          } else if (msg.toLowerCase().includes("invalid signature")) {
            showStatus(
              "Invalid signature — the IOU may have been signed incorrectly",
              "error"
            );
          } else if (msg.toLowerCase().includes("caller must be the payee")) {
            showStatus("Only the recipient can claim this IOU", "error");
          } else {
            showStatus(`Failed to claim IOU: ${msg}`, "error");
          }
        }
      }


      function buildCancelMessage(authorizer, nonce) {
        return {
          authorizer: ethers.utils.getAddress(authorizer),
          nonce: ethers.utils.hexZeroPad(nonce, 32),
        };
      }


      async function revokeSlip(localId) {
        const slip = slips.find(
          (s) => slipLocalId(s.from, s.nonce) === localId
        );
        if (!slip) return;
        try {
          if (!signer) throw new Error("Connect your wallet first.");


          // Ensure correct chain for the slip
          const net = await provider.getNetwork();
          if (slip.chainId && net.chainId !== slip.chainId) {
            showStatus(
              `Please switch to ${
                slip.chainId === BASE_CHAIN_ID
                  ? "Base Mainnet"
                  : "Ethereum Mainnet"
              } to revoke this authorization.`,
              "error"
            );
            return;
          }


          if (account.toLowerCase() !== slip.from.toLowerCase()) {
            showStatus("Only the authorizer can revoke.", "error");
            return;
          }
          const used = await usdc.authorizationState(slip.from, slip.nonce);
          if (used) {
            showStatus("Already used; cannot revoke.", "error");
            return;
          }
          if (isExpired(slip)) {
            showStatus("Already expired; no need to revoke.", "info");
            return;
          }


          // --- EIP-712 cancel signing ---
          const message = buildCancelMessage(slip.from, slip.nonce);
          let signature;
          try {
            signature = await signer._signTypedData(
              domain,
              CANCEL_TYPES,
              message
            );
          } catch (err) {
            if (isUserRejected(err)) {
              showStatus("Revoke signature canceled.", "info");
              return;
            }
            throw err;
          }
          const { v, r, s } = ethers.utils.splitSignature(signature);


          // --- On-chain cancel with the signed (v,r,s) ---
          const est = await usdc.estimateGas
            .cancelAuthorization(message.authorizer, message.nonce, v, r, s)
            .catch(() => ethers.BigNumber.from("80000"));


          const tx = await usdc.cancelAuthorization(
            message.authorizer,
            message.nonce,
            v,
            r,
            s,
            { gasLimit: est.mul(120).div(100) }
          );


          showStatus("Submitting revoke…", "info");
          const receipt = await tx.wait();


          deleteSlip(localId);
          const explorerTx =
            slip.chainId === BASE_CHAIN_ID
              ? `https://basescan.org/tx/${receipt.transactionHash}`
              : `https://etherscan.io/tx/${receipt.transactionHash}`;
          showStatus(
            `Authorization revoked. Explorer: ${explorerTx}`,
            "success"
          );
        } catch (err) {
          if (isUserRejected(err)) {
            showStatus("Revoke transaction canceled.", "info");
            return;
          }
          showStatus(
            `Failed to revoke: ${err?.reason || err?.message || err}`,
            "error"
          );
        }
      }


      // --------------------
      // Intro
      // --------------------
      function checkIntroShown() {
        const shown = localStorage.getItem("iousdc_intro_shown");
        if (!shown) $("introPopup").style.display = "flex";
      }
      function closeIntro() {
        $("introPopup").style.display = "none";
        localStorage.setItem("iousdc_intro_shown", "true");
      }
      function openIntro() {
        $("introPopup").style.display = "flex";
      }


      // --------------------
      // Event Listeners
      // --------------------
      document.querySelectorAll(".auth-type-btn").forEach((btn) => {
        btn.addEventListener("click", function () {
          document
            .querySelectorAll(".auth-type-btn")
            .forEach((b) => b.classList.remove("selected"));
          this.classList.add("selected");
          selectedAuthType = this.dataset.type;
        });
      });


      $("connectBtn").addEventListener("click", connectWallet);
      $("disconnectBtn").addEventListener("click", disconnectWallet);
      $("switchBtn").addEventListener("click", switchToCorrectNetwork);
      $("createSlipBtn").addEventListener("click", createSlip);
      $("prefillSelfBtn").addEventListener("click", async () => {
        if (!account) {
          showStatus("Connect your wallet first", "info");
          return;
        }
        $("recipientAddress").value = account;
      });
      $("fileInput").addEventListener("change", handleFileUpload);


      // Toggle Base mode button
      $("baseToggle").addEventListener("click", async () => {
        const next = networkMode === "base" ? "ethereum" : "base";
        setNetworkMode(next);
        const onCorrect = provider ? await ensureCorrectNetwork(true) : false;
        if (provider && !onCorrect) {
          showStatus(
            `You're in ${getActiveConfig().label} mode. Click "Switch to ${
              networkMode === "base" ? "Base" : "Mainnet"
            }" to change networks in your wallet.`,
            "info"
          );
        }
      });


      $("pasteToggleBtn").addEventListener("click", () => {
        const p = $("pastePanel");
        p.hidden = !p.hidden;
        if (!p.hidden) $("pasteTextarea").focus();
      });
      $("pasteAddBtn").addEventListener("click", () =>
        addSlipFromText($("pasteTextarea").value)
      );
      $("pasteClearBtn").addEventListener("click", () => {
        $("pasteTextarea").value = "";
        $("pasteTextarea").focus();
      });


      // Drag & drop
      const uploadArea = document.getElementById("uploadArea");
      const browseBtn = document.getElementById("browseBtn");


      if (browseBtn) {
        browseBtn.addEventListener("click", () => $("fileInput").click());
      }


      if (uploadArea) {
        // Paste into the area (focus the box or click it; it has tabindex=0)
        uploadArea.addEventListener("paste", (e) => {
          const text = (e.clipboardData || window.clipboardData)?.getData(
            "text"
          );
          if (text && text.trim()) {
            e.preventDefault(); // don’t insert text into the box
            addSlipFromText(text);
          }
        });


        // Drag & drop
        ["dragover", "dragenter"].forEach((ev) =>
          uploadArea.addEventListener(ev, (e) => {
            e.preventDefault();
            uploadArea.style.background = "rgba(102,126,234,.2)";
          })
        );
        ["dragleave", "drop"].forEach((ev) =>
          uploadArea.addEventListener(ev, (e) => {
            e.preventDefault();
            uploadArea.style.background = "rgba(102,126,234,.05)";
          })
        );
        uploadArea.addEventListener("drop", (e) => {
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            handleFileUpload({ target: { files } });
          }
        });
      }


      document.addEventListener("paste", (e) => {
        const t = e.target;
        if (
          t &&
          (t.tagName === "INPUT" ||
            t.tagName === "TEXTAREA" ||
            t.isContentEditable)
        )
          return;


        const area = document.getElementById("uploadArea");
        const panel = document.getElementById("pastePanel");
        const areaVisible = !!area && area.offsetParent !== null;
        const panelVisible =
          !!panel && panel.offsetParent !== null && !panel.hidden;
        if (!areaVisible && !panelVisible) return;


        const text = (e.clipboardData || window.clipboardData)?.getData("text");
        if (text && text.trim()) addSlipFromText(text);
      });


      // Wallet events (smoother account/network switching)
      if (window.ethereum) {
        window.ethereum.on?.("accountsChanged", async (accounts) => {
          if (!accounts?.length) {
            disconnectWallet();
            return;
          }
          try {
            const addr = ethers.utils.getAddress(accounts[0]);
            account = addr;
            if (provider) {
              signer = provider.getSigner(addr);
            } else {
              provider = new ethers.providers.Web3Provider(
                window.ethereum,
                "any"
              );
              signer = provider.getSigner(addr);
            }
            // Align mode with network on account switch
            const net = await provider.getNetwork();
            chainId = net.chainId;
            if (chainId === BASE_CHAIN_ID) {
              setNetworkMode("base", { silent: true });
            } else {
              setNetworkMode("ethereum", { silent: true });
            }
            bindUsdcContract();
            await postConnectSetup(false);
          } catch (e) {
            console.error(e);
          }
        });


        window.ethereum.on?.("chainChanged", async () => {
          try {
            if (!window.ethereum) return;
            if (!provider)
              provider = new ethers.providers.Web3Provider(
                window.ethereum,
                "any"
              );
            // Refresh signer/usdc with new network context
            if (account) signer = provider.getSigner(account);


            const net = await provider.getNetwork();
            chainId = net.chainId;
            if (chainId === BASE_CHAIN_ID) {
              setNetworkMode("base", { silent: true });
            } else {
              setNetworkMode("ethereum", { silent: true });
            }


            bindUsdcContract();
            await postConnectSetup(false);
          } catch (e) {
            console.error(e);
          }
        });
      }


      // --------------------
      // Init
      // --------------------
      checkIntroShown();
      loadSlips();
      tryAutoconnect();


      // Optional: sanity-check Base domain separator when toggling to Base (dev console only)
      (function () {
        try {
          const baseDom = buildDomain(BASE_CHAIN_ID, BASE_USDC_ADDRESS);
          const sep = ethers.utils._TypedDataEncoder.hashDomain(baseDom);
          if (sep.toLowerCase() !== BASE_DOMAIN_SEPARATOR.toLowerCase()) {
            console.warn(
              "Base USDC domain separator mismatch. Expected",
              BASE_DOMAIN_SEPARATOR,
              "got",
              sep
            );
          }
        } catch {}
      })();
    </script>
  </body>
</html>
